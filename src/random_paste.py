# Date: 2024/4/17
from segment_fore_back import segment_fore_back
import matplotlib.pyplot as plt
import numpy as np
from numpy.typing import NDArray
import random
import copy


class ObjMap:
    """
    A class to handle object mapping onto an image.
    ---
    Attributes:
        img: the Chinese Painting
        obj: the pure seal/inscriptionimage generated by 'filter_seals_inscriptions.py'
        dic: the mapping of object pixels to image coordinates (e.g. {(0, 0):
             np.array(0., 0., 0.)})
    """

    def __init__(self, img: NDArray[np.float32], obj: NDArray[np.float32]) -> None:
        self.img = img
        self.obj = obj
        self.dic = self.random_location_not_conflict()

    def random_location(self) -> dict[tuple[int], NDArray[np.float32]]:
        """
        Randomly selects a location for the object within the Chinese Painting
        image. The condition is that the entire object must fit within the image
        (no cropping).
        """
        img_h, img_w, _ = self.img.shape
        # calculate object width & height
        obj_h, obj_w, _ = self.obj.shape
        obj_h_half, obj_w_half = (int(i / 2) for i in (obj_h, obj_w))
        # randomly generate object center index based image shape
        obj_center_x = random.randint(0 + obj_w_half + 1, img_w - obj_w_half - 2)
        obj_center_y = random.randint(0 + obj_h_half + 1, img_h - obj_h_half - 2)
        # get object's location of the image
        obj_idx_x = list(
            range(obj_center_x - obj_w_half, obj_center_x + obj_w_half + 1)
        )
        obj_idx_y = list(
            range(obj_center_y - obj_h_half, obj_center_y + obj_h_half + 1)
        )
        # get the object location of image and its idx:val dict
        obj_location = [(j, i) for i in obj_idx_x for j in obj_idx_y]
        obj_val_flat = self.obj.transpose(1, 0, 2).reshape(-1, 3)
        return {k: v for k, v in zip(obj_location, obj_val_flat)}

    def random_location_not_conflict(self) -> dict[tuple[int], NDArray[np.float32]]:
        """
        Just like random_location, but if the object box has conflict with the
        image's foreground, regenerate.
        """
        self.img_binary = segment_fore_back(self.img)
        self.img_rgb_binary = np.stack([self.img_binary for _ in range(3)], axis=-1)
        obj_location = self.random_location()
        while sum([not all(self.img_rgb_binary[i]) for i in obj_location.keys()]) != 0:
            obj_location = self.random_location()
        return obj_location

    def filter_white(self) -> dict[tuple[int], NDArray[np.float32]]:
        def is_white(arr: NDArray[np.float32]) -> bool:
            """the shape of arr is (3,)"""
            return all(arr.round(decimals=2) == 1)

        return {k: v for k, v in self.dic.items() if not is_white(v)}


def random_paste(
    img: NDArray[np.float32], obj: NDArray[np.float32], return_process_imgs=False
):
    """
    Pastes an object onto an image at a random location.
    ---
    img: the Chinese Painting
    obj: the pure seal/inscriptionimage generated by 'filter_seals_inscriptions.py'
    return_process_imgs:
        If False, return pasted image. If True, return [origin, binary,
        binary_pasted, origin_pasted] images list.
    """

    def assign_val_based_dict(img, dic: dict[tuple[int], NDArray[np.float32]]) -> None:
        for k, v in dic.items():
            img[k] = v
        return None

    obj_map = ObjMap(img, obj)
    if not return_process_imgs:
        img_obj = img
        assign_val_based_dict(img_obj, obj_map.filter_white())
        return img_obj
    else:
        # binary image
        img_rgb_binary = obj_map.img_rgb_binary.astype(np.float32)
        # binary image with object *box* pasted
        ys, xs = [i[0] for i in obj_map.dic.keys()], [i[1] for i in obj_map.dic.keys()]
        min_y, max_y, min_x, max_x = min(ys), max(ys), min(xs), max(xs)
        obj_map_dic_with_box = copy.deepcopy(obj_map.dic)
        for k, v in obj_map.dic.items():
            if k[0] in [min_y, max_y] or k[1] in [min_x, max_x]:
                obj_map_dic_with_box[k] = np.array([0.0, 0.0, 0.0])
        img_rgb_binary_obj = np.copy(img_rgb_binary)
        assign_val_based_dict(img_rgb_binary_obj, obj_map_dic_with_box)
        # original image with object pasted
        img_obj = np.copy(img)
        assign_val_based_dict(img_obj, obj_map.filter_white())
        return [img, img_rgb_binary, img_rgb_binary_obj, img_obj]


if __name__ == "__main__":
    img = plt.imread("../assets/image_nosi.png")
    obj = plt.imread("../assets/seal.png")
    process_imgs = random_paste(img, obj, return_process_imgs=True)
    fig, axes = plt.subplots(1, 4, constrained_layout=True, figsize=(12, 3))
    for i, ax in enumerate(axes):
        ax.imshow(process_imgs[i])
        ax.axis("off")
    plt.show()
