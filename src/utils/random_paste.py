# Date: 2024/4/17
from segment_fore_back import segment_fore_back
import matplotlib.pyplot as plt
import numpy as np
from numpy.typing import NDArray
import random
import copy


class ObjMap:
    """
    A class to handle object mapping onto an image.
    ---
    Attributes:
        img: the Chinese Painting
        obj: the pure seal/inscriptionimage generated by 'filter_seals_inscriptions.py'
        dic: the mapping of object pixels to image coordinates (e.g. {(0, 0):
             np.array(0., 0., 0.)})
    """

    def __init__(self, img: NDArray[np.float32], obj: NDArray[np.float32]) -> None:
        self.img = img
        self.obj = obj
        self.dic = self.located_filter_white()

    def random_location(self) -> dict[tuple[int], NDArray[np.float32]]:
        """
        Randomly selects a location for the object within the Chinese Painting
        image. The condition is that the entire object must fit within the image
        (no cropping).
        """
        img_h, img_w, _ = self.img.shape
        # calculate object width & height
        obj_h, obj_w, _ = self.obj.shape
        obj_h_half, obj_w_half = (int(i / 2) for i in (obj_h, obj_w))
        # randomly generate object center index based image shape
        obj_center_x = random.randint(0 + obj_w_half + 1, img_w - obj_w_half - 2)
        obj_center_y = random.randint(0 + obj_h_half + 1, img_h - obj_h_half - 2)
        # get object's location of the image
        obj_idx_x = list(
            range(obj_center_x - obj_w_half, obj_center_x + obj_w_half + 1)
        )
        obj_idx_y = list(
            range(obj_center_y - obj_h_half, obj_center_y + obj_h_half + 1)
        )
        # get the object location of image and its idx:val dict
        obj_location = [(j, i) for i in obj_idx_x for j in obj_idx_y]
        obj_val_flat = self.obj.transpose(1, 0, 2).reshape(-1, 3)
        return {k: v for k, v in zip(obj_location, obj_val_flat)}

    def random_location_not_conflict(self) -> dict[tuple[int], NDArray[np.float32]]:
        """
        Just like random_location, but if the object box has conflict with the
        image's foreground, regenerate. 
        ---
        Note: If this function can't find a good location, it will return an
        empty dict `{}`.
        """
        self.img_binary = segment_fore_back(self.img)
        self.img_rgb_binary = np.stack([self.img_binary for _ in range(3)], axis=-1)
        obj_location = self.random_location()
        flag = 1
        while sum([not all(self.img_rgb_binary[i]) for i in obj_location.keys()]) != 0:
            obj_location = self.random_location()
            if flag in [1, 10, 20, 30, 40, 50]:
                print(f"[INFO]         run random location: {flag}")
            if flag == 50:
                obj_location = {}
                print("\033[93m[WARN]         can't find a good location\033[0m")
                break
            flag += 1
        return obj_location

    def located_filter_white(self) -> dict[tuple[int], NDArray[np.float32]]:
        def is_white(arr: NDArray[np.float32]) -> bool:
            """the shape of arr is (3,)"""
            return all(arr.round(decimals=2) == 1)

        return {k: v for k, v in self.random_location_not_conflict().items() if not is_white(v)}


def assign_val_based_dict(img, dic: dict[tuple[int], NDArray[np.float32]]) -> None:
    for k, v in dic.items():
        img[k] = v
    return None


def random_paste(
    img: NDArray[np.float32], obj: NDArray[np.float32], process_type: str = "none"
):
    """
    Pastes an object onto an image at a random location.
    ---
    img: the Chinese Painting
    obj: the pure seal/inscriptionimage generated by 'filter_seals_inscriptions.py'
    return_process_imgs:
        'none': return pasted image;
        'mask': return [origin_pasted, mask];
        'all' : return [origin, binary, mask, binary_pasted, origin_pasted] images list.
    ---
    Note: This function maybe can't find a good location, in this situation,
    it's mask will be filled of 0.
    """
    def get_mask(img, obj_map):
        mask = np.zeros(img.shape[:2], dtype=np.uint8)
        obj_map_dic_mask = copy.deepcopy(obj_map.dic)
        for k in obj_map_dic_mask.keys():
            obj_map_dic_mask[k] = 1
        assign_val_based_dict(mask, obj_map_dic_mask)
        return mask

    obj_map = ObjMap(img, obj)
    if process_type == "none":
        img_obj = img
        assign_val_based_dict(img_obj, obj_map.dic)
        return img_obj
    elif process_type == "mask":
        img_obj = img
        assign_val_based_dict(img_obj, obj_map.dic)
        mask = get_mask(img, obj_map)
        return [img_obj, mask]
    elif process_type == "all":
        # binary image
        img_rgb_binary = obj_map.img_rgb_binary.astype(np.float32)
        # mask image
        mask = get_mask(img, obj_map)
        # binary image with object *box* pasted
        ys, xs = [i[0] for i in obj_map.dic.keys()], [i[1] for i in obj_map.dic.keys()]
        min_y, max_y, min_x, max_x = min(ys), max(ys), min(xs), max(xs)
        obj_map_dic_with_box = copy.deepcopy(obj_map.dic)
        for k, v in obj_map.dic.items():
            if k[0] in [min_y, max_y] or k[1] in [min_x, max_x]:
                obj_map_dic_with_box[k] = np.array([0.0, 0.0, 0.0])
        img_rgb_binary_obj = np.copy(img_rgb_binary)
        assign_val_based_dict(img_rgb_binary_obj, obj_map_dic_with_box)
        # original image with object pasted
        img_obj = np.copy(img)
        assign_val_based_dict(img_obj, obj_map.dic)
        return [img, img_rgb_binary, mask, img_rgb_binary_obj, img_obj]


def random_paste_multi(img: NDArray[np.float32], objs: list[NDArray[np.float32]]) -> list[NDArray[np.float32], NDArray[np.uint8]]:
    """
    Note: This function maybe can't find a good location, in this situation,
    it's mask will be filled of 0.
    """
    print("[INFO] start random paste multi")
    mask = np.zeros(img.shape[:2])
    for obj in objs:
        print("[INFO]     got one obj, run random paste")
        img, mask_obj = random_paste(img, obj, process_type="mask")
        mask += mask_obj * (np.max(mask) + 1)
        print("[INFO]     pasted one obj, good")
    print("[INFO] end random paste multi\n")
    return [img, mask.astype(np.uint8)]


if __name__ == "__main__":
    img = plt.imread("../../assets/image_nosi.png")
    obj = plt.imread("../../assets/seal.png")
    obj2 = plt.imread("../../assets/inscription.png")
    objs = [obj, obj2]

    # Plot all process_imgs
    process_imgs = random_paste(img, obj, process_type="all")
    fig, axes = plt.subplots(1, 5, constrained_layout=True, figsize=(12, 3))
    for i, ax in enumerate(axes):
        ax.imshow(process_imgs[i])
        ax.axis("off")
    plt.show()

    # Plot multi pasted img
    img_pasted, mask = random_paste_multi(img, objs)
    fig, axes = plt.subplots(1, 2, constrained_layout=True)
    axes[0].imshow(img_pasted)
    axes[1].imshow(mask)
    plt.show()
